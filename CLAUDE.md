# CLAUDE.md - AI Assistant Guide for cfomics

## Package Overview

**cfomics** (Counterfactual Causal Inference for Omics Data) is an R package providing a unified interface for causal inference methods designed for high-dimensional biological data. It supports Bioconductor data structures (SummarizedExperiment, MultiAssayExperiment) and offers both Python-based deep learning methods and R-native statistical approaches.

- **Version**: 0.4.0
- **License**: MIT
- **Author**: Yusuke Matsui
- **R Requirement**: >= 4.2.0

## Repository Structure

```
cfomics/
├── R/                          # R source files
│   ├── aaa-onload.R           # Package load hooks (NO side effects)
│   ├── cf_fit.R               # Main unified fitting API
│   ├── cf_predict.R           # Prediction methods
│   ├── config.R               # Configuration management (~/.cfomics/)
│   ├── python_env.R           # Python environment management
│   ├── methods_traditional.R  # R-native methods (GRF, IPW, G-formula)
│   ├── methods_dowhy_gcm.R    # DoWhy-GCM Python backend
│   ├── methods_ganite.R       # GANITE Python backend
│   ├── methods_drlearner.R    # DRLearner/EconML Python backend
│   ├── methods_cavae.R        # CAVAE Python backend
│   ├── bioc_integration.R     # Bioconductor data converters
│   ├── benchmark_*.R          # Benchmarking infrastructure
│   ├── visualization.R        # Plotting functions
│   ├── diagnostics.R          # Assumption checking
│   ├── result_contract.R      # Result object specification
│   └── formula_utils.R        # Formula parsing (Y ~ T | X1 + X2)
├── inst/
│   ├── python/                # Python backend scripts
│   │   ├── gcm_dowhy.py       # DoWhy wrapper
│   │   ├── ganite.py          # GANITE implementation
│   │   ├── visualization.py   # Python plotting
│   │   └── requirements.txt   # Python dependencies
│   ├── benchmarks/            # Benchmark scripts
│   └── scripts/               # Utility scripts
├── tests/testthat/            # Unit tests (testthat v3)
├── man/                       # Generated documentation (roxygen2)
├── vignettes/                 # Package vignettes
├── data-raw/                  # Data generation scripts
├── tools/                     # Development tools
│   └── check_package.R        # Package check script
├── DESCRIPTION                # Package metadata
├── NAMESPACE                  # Exports (auto-generated by roxygen2)
└── NEWS.md                    # Changelog
```

## Key Design Patterns

### 1. Unified API via `cf_fit()`

All causal inference methods are accessed through a single entry point:

```r
cf_fit(formula, data, method = "grf", ...)
```

The `method` argument dispatches to backend-specific implementations:
- R-native: `cf_fit_grf()`, `cf_fit_ipw()`, `cf_fit_gformula()`
- Python: `cf_fit_dowhy_gcm()`, `cf_fit_ganite()`, `cf_fit_drlearner()`, `cf_fit_cavae()`

### 2. Formula Syntax

cfomics uses a special formula syntax: `Y ~ T | X1 + X2 + X3`
- `Y`: Outcome variable (numeric)
- `T`: Treatment variable (binary: 0/1)
- `X1, X2, X3`: Covariates (numeric)

### 3. Result Contract (`cfomics_result`)

All methods return a standardized object with class `c("cf_model", "cfomics_result")`:

```r
list(
  method = "grf",           # Method identifier
  fit = list(               # Method-specific fit
    model = ...,            # Underlying model object
    res = list(             # REQUIRED results
      ite = numeric(),      # Individual Treatment Effects
      ate = numeric(1),     # Average Treatment Effect
      y0_hat = numeric(),   # Counterfactual: untreated
      y1_hat = numeric(),   # Counterfactual: treated
      summary = list(       # Summary statistics
        ate = ...,
        ate_ci_lower = ...,
        ate_ci_upper = ...,
        ite_mean = ...,
        ite_std = ...,
        ite_quantiles = list(q05, q50, q95)
      )
    )
  ),
  meta = list(              # Metadata
    formula = ...,
    n = ..., p = ...,
    outcome_name = ...,
    treatment_name = ...,
    covariate_names = ...,
    estimand = "ATE",
    software_versions = ...
  )
)
```

Validation is enforced via `validate_cfomics_result()`.

### 4. Python Environment Management

**Important**: cfomics does NOT auto-initialize Python at package load.

Users must explicitly configure Python before using Python-based methods:

```r
# Option 1: Use cfomics helper functions
cf_install_python_env("unified")
cf_use_python_env("unified")

# Option 2: User-managed environment
reticulate::use_condaenv("my_env", required = TRUE)

# Option 3: Environment variable
Sys.setenv(RETICULATE_PYTHON = "/path/to/python")
```

Key functions:
- `cf_has_python(method)` - Check availability WITHOUT initializing
- `cf_require_python(method)` - Require Python, error if unavailable
- `cf_check_env()` - Diagnostic report

### 5. Configuration

Persistent configuration stored in `~/.cfomics/config.yaml`:

```r
cf_config()                        # View all settings
cf_config("methods.default")       # Get specific value
cf_config("methods.default", "grf") # Set value
cf_config_reset()                  # Reset to defaults
```

## Development Workflow

### Running Tests

```bash
# All tests
Rscript -e 'devtools::test()'

# Specific test file
Rscript -e 'testthat::test_file("tests/testthat/test-traditional.R")'

# Tests with Python methods (requires Python setup)
RETICULATE_PYTHON=/path/to/python Rscript -e 'devtools::test()'
```

### Package Checks

```bash
# Quick check (no vignettes/manual)
Rscript tools/check_package.R --quick

# Full CRAN-style check
Rscript tools/check_package.R --full

# With BiocCheck
Rscript tools/check_package.R --bioc
```

### Documentation

```bash
# Regenerate documentation (roxygen2)
Rscript -e 'devtools::document()'

# Build vignettes
Rscript -e 'devtools::build_vignettes()'
```

### Manual Build

```bash
R CMD build .
R CMD check --as-cran cfomics_*.tar.gz
```

## Coding Conventions

### R Code Style

1. **Function naming**: `cf_*` prefix for exported functions
2. **Internal functions**: Document with `@noRd` and `@keywords internal`
3. **Imports**: Use `@importFrom` instead of full package imports
4. **Error handling**: Use `rlang::abort()` with custom error classes
5. **Warnings**: Use `rlang::warn()` with `class = "cfomics_*_warning"`
6. **CLI messages**: Use `cli` package for user-facing messages

### Python Integration

1. Never initialize Python in `.onLoad()` or at package load
2. Use `cf_require_python()` at the start of Python-dependent functions
3. Python modules are loaded lazily via helper functions (e.g., `.get_dowhy_module()`)
4. All Python calls should be wrapped in appropriate error handling

### Testing Conventions

1. Use `testthat` edition 3
2. Skip Python-dependent tests appropriately:
   ```r
   skip_if_not(reticulate::py_available(initialize = TRUE))
   skip_if_not(reticulate::py_module_available("dowhy"))
   ```
3. Test files are named `test-*.R`
4. Use `helper-*.R` for shared test utilities

### Result Object Requirements

When adding a new method:
1. Return object must conform to `cfomics_result` contract
2. Include all required fields in `fit$res`
3. Call `validate_cfomics_result()` before returning
4. Add predict/summary/print methods as needed

## Available Methods

| Method | Backend | Python Required | Package Dependencies |
|--------|---------|-----------------|---------------------|
| `grf` | R (grf) | No | grf |
| `ipw` | R (ipw) | No | ipw, survey |
| `gformula` | R | No | None (base R lm) |
| `dowhy_gcm` | Python | Yes | dowhy |
| `drlearner` | Python | Yes | econml |
| `ganite` | Python | Yes | tensorflow |
| `cavae` | Python | Yes | torch, pyro-ppl |

## Bioconductor Integration

The package supports:
- `SummarizedExperiment`: Gene expression with sample metadata
- `MultiAssayExperiment`: Multi-omics integration

Key function: `as_cf_data()` converts Bioconductor objects to cfomics format.

Feature selection options: `"variance"`, `"pca"`, `"none"`

## Common Tasks

### Adding a New Causal Inference Method

1. Create `R/methods_newmethod.R` with:
   - `cf_fit_newmethod()` - Fitting function
   - `predict_cf_newmethod()` - Prediction function
2. Add method to `cf_fit()` switch statement
3. Add method to `select_best_method()` if R-native
4. Add tests in `tests/testthat/test-newmethod.R`
5. Update NAMESPACE via roxygen2

### Adding a New Visualization

1. Add to `R/visualization.R`
2. Export with `@export` tag
3. Add to `cf_plot_all()` if appropriate
4. Add tests in `test-visualization.R`

### Modifying Result Structure

1. Update `result_contract.R` documentation
2. Update `validate_cfomics_result()`
3. Update all method implementations
4. Update print/summary/predict S3 methods

## Important Files to Review

- `R/result_contract.R` - Understanding the result object contract
- `R/cf_fit.R` - Main API and method dispatch
- `R/python_env.R` - Python environment management patterns
- `tests/testthat/test-python-methods-structure.R` - Expected method behavior
- `DESCRIPTION` - Package dependencies

## Troubleshooting

### Python Not Found
```r
cf_check_env()  # Diagnose environment
cf_install_python_env("unified")  # Install cfomics conda env
cf_use_python_env("unified")  # Activate
```

### Test Failures
- Ensure Python environment is configured if testing Python methods
- Run `devtools::load_all()` before running tests
- Check for missing Suggested packages

### R CMD check Issues
- Avoid global variable NOTEs: declare in `aaa-onload.R` with `globalVariables()`
- Ensure all examples are wrapped in `\donttest{}` or `\dontrun{}` if they need Python
